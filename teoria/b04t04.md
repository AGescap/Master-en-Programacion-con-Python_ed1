# Simulación de tipos, y protocolos

Las clases definidas por el usuario pueden comportarse como otros tipos gracias
a la implementación de diversos métodos mágicos. Este tema ilustra cómo se
implementan algunos de ellos para emular tipos numéricos, contenedores y
funciones.

El tema finaliza con la implementación de iteradores, generadores y contextos,
tipos todos ellos para los que Python tiene una sintaxis especial.

* La documentación de Python sobre
[métodos especiales](https://docs.python.org/3/reference/datamodel.html#special-method-names)
lista todos los métodos mágicos.

## Invocación e implementación de métodos mágicos

Los métodos mágicos son invocados por el intérprete de Python al utilizar
cierta clase de sintaxis o utilizar un cierto tipo de funcionalidad.
Por ejemplo, cuando hacemos:

```python
3 + 5
```

En realidad estamos haciendo:

```python
int.__add__(3, 5)
```

O, también:

```python
3 in [1, 2, 5]
```

Que se traduce a:

```python
list.__contains__([1, 2, 5], 3)
```

Fíjate en como los parámetros no siempre se pasan en el orden en que aparecen
en la sintaxis.

Sea como sea, los métodos mágicos **siempre se llaman desde el tipo del valor**,
pasando explícitamente los valores de `self` y del resto de parámetros.

La implementación de métodos mágicos se **tiene que hacer en la clase**. De
nada sirve hacer algo así:

```python
class NerdAlien:
    pass

o = NerdAlien()
o.__repr__ = lambda: 'I am Ziltoid!'
repr(o)
```

La forma correcta es hacer:

```python
class NerdAlien:
    def __repr__(self):
        return 'I am Ziltoid!'
o = NerdAlien()
repr(o)
```

¿Por qué la primera forma no funciona y la segunda sí?

### Simulando un tipo numérico: vectores bidimensionales

Vamos a crear un vector bidimensional `Vector2D` e implementaremos algunas
operaciones de los tipos numéricos.

1. Comencemos con lo básico:

    ```python
    class Vector2D:
        """A vector in a 2D euclidean space."""

        def __init__(self, x=0, y=0):
            self.x = x
            self.y = y
    ```

    Recuerda que habrás de modificar la clase entera cada vez que añadas
    un nuevo método.

2. Ahora crea un punto:

    ```python
    Vector2D(10, 10)
    ```

    Mira la representación por defecto. Vamos a mejorarla implementando el
    método mágico `__repr__`:

    ```python
    # inside the Vector2D class
    def __repr__(self):
        return f'{self.__class__.__name__}({self.x}, {self.y})'
    ```

3. Continuamos con la suma y resta:

    ```python
    # inside the Vector2D class
    def __add__(self, other):
        if isinstance(other, Vector2D):
            return Vector2D(self.x + other.x, self.y + other.y)

        return NotImplemented

    def __sub__(self, other):
        if isinstance(other, Vector2D):
            return Vector2D(self.x - other.x, self.y - other.y)

        return NotImplemented
    ```

    Fíjate en `NotImplemented`. No lo confundas con la clase de exepción
    `NotImplementedError`. `NotImplemented` es un **valor** que indica
    que una operación no se encuentra disponible para un determinado tipo
    de argumento. En nuestro caso, sólo implementamos la suma o la resta
    cuando el otro argumento es un `Vector2D`.

    Prueba ahora:

    ```python
    Vector2D(1, -5) + Vector2D(10, 10)
    ```

4. Continuemos con algo más interesante, la negación, la multiplicación por
un escalar y la división (en su versión con decimales):

    ```python
    # inside the class Vector2D
    def __neg__(self):
        return Vector2D(-self.x, -self.y)

    def __mul__(self, scalar):
        import numbers
        if isinstance(scalar, numbers.Real):
            return Vector2D(self.x * scalar, self.y * scalar)

        return NotImplemented

    def __truediv__(self, scalar):
        import numbers
        if isinstance(scalar, numbers.Real):
            return Vector2D(self.x / scalar, self.y / scalar)

        return NotImplemented
    ```

    Con esto podemos hacer cosas como:

    ```python
    -Vector2D(10, -10)
    Vector2D(1, 1) * 5
    Vector2D(5, 5) / 5
    ```

    Sin embargo, no podemos hacer:

    ```python
    5 * Vector2D(1, 1)
    ```

5. Esto se debe a que la expresión anterior es equivalente a:

    ```python
    int.__mul__(5, Vector2D(1, 1))
    ```

    Y el tipo `int` no podía saber de antemano cómo sumar un `Vector2D`.

    Para poder arreglar esta situación, Python establece un protocolo: si
    una operación falla con `NotImplemented`, se llama a su versión "refleja"
    (mismo nombre del método mágico precedido de una `r`). Sólo si esta también
    devuelve `NotImplemented` se deduce que la operación no está soportada.

    Ahora sabemos que cuando la operación anterior falle, Python intentará:

    ```python
    Vector2D.__rmul__(Vector2D(1, 1), 5)
    ```

    Así que implementamos `__rmul__`:

    ```python
    # inside the Vector2D class
    def __rmul__(self, scalar):
        return self * scalar
    ```

    Y ya podemos hacer cosas como:

    ```python
    5 * Vector2D(1, 1)
    ```

    Consulta la
    [documentación de los operadores "reflejos"](https://docs.python.org/3/reference/datamodel.html#object.__radd__)
    para una lista eshaustiva.

    Antes de continuar, prueba a implementar la división entera. ¿Tiene
    sentido implementar la división refleja para el tipo `Vector2D`?

6. Existe toda una serie de operaciones _in place_ (in situ):

    ```python
    5 += 1
    7 -= 10
    8 *= -1
    ```

    Cuando el tipo es inmutable, estas operaciones no tienen más remedio que
    devolver un nuevo valor. Pero cuando los tipos son mutables, Python
    recomienda que, en la medida de los posible, la modificación se realice
    sobre el primer operando.

    Si decidimos que `Vector2D` sea mutable, podemos implementar las versiones
    in situ de las operaciones que ya hemos implementado de la siguiente
    manera:

    ```python
    # inside the Vector2D class
        def __iadd__(self, other):
            if isinstance(other, Vector2D):
                self.x += other.x
                self.y += other.y
                return self

            return NotImplemented
    ```

    Consulta la
    [documentación de las operaciones in situ](https://docs.python.org/3/reference/datamodel.html#object.__iadd__)
    e implementa el resto.

7. Cambia la definición de la multiplicación para que permita "multiplicar
por un vector". Implementa el
[producto escalar](https://es.wikipedia.org/wiki/Producto_escalar) para estos
casos.

8. También podemos alterar la forma en que un tipo se comporta en una
expresión booleana, es decir, cuándo se considera verdadero y cuándo falso. Por
ejemplo, sería conveniente que el vector cero, `Vector2D()` fuera considerado
falso. Sin embargo:

    ```python
    origin = Vector2D()
    bool(origin)
    ```

    Podemos cambiar este comportamiento, implementando el método mágico
    `__bool__` (que debe devolver `True` o `False`):

    ```python
    # inside the Vector2D class
    def __bool__(self):
        return bool(self.x or self.y)
    ```

    Comprueba que la modificación ha servido de algo.

    En la documentación se muestra que además de
    [`__bool__`](https://docs.python.org/3/reference/datamodel.html#object.__bool__),
    también puedes implementar la
    [conversión a otros tipos](https://docs.python.org/3/reference/datamodel.html#object.__complex__).

* Documentación acerca de la
[emulación de tipos numéricos](https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types).

### Simulando un tipo contenedor

Continuamos simulando otros tipos, implementando los métodos mágicos típicos
de un contenedor. Nótese que la forma más sencilla sería heredar de alguna
de las clases abstractas de `collections.abc` como hacíamos en el tema
anterior pero esta aproximación también sirve.

1. Comencemos por implementar la longitud de `Vector2D`:

    ```python
    # inside the Vector2D class
    def __len__(self):
        return 2
    ```

    Con lo que ya podemos hacer:

    ```python
    len(Vector2D(1, 1))
    ```

2. Permitamos ahora indexar los componentes del vector:

    ```python
        # inside the Vector2D class
        def __getitem__(self, index):
            index = self._correct_index(index)
            return self.x if index == 0 else self.y

        def __setitem__(self, index, value):
            index = self._correct_index(index)
            if index == 0:
                self.x = value
            else:
                self.y = value

        def _correct_index(self, index):
            if index < 0:
                index += len(self)
            if index < 0 or index >= len(self):
                raise IndexError
            return index
    ```

3. Nos faltaría el test de pertenencia y la iteración, es decir, las
sintáxis:

    ```python
    v = Vector2D(10, -10)
    10 in v
    for item in v:
        print(item)
    ```

    Implementaremos aquí el primero, dejando el segundo para la última
    sección del tema:

    ```python
    # inside the Vector2D class
    def __contains__(self, item):
        return self.x == item or self.y == item
    ```

* Documentación acerca de la
[emulación de tipos contenedor](https://docs.python.org/3/reference/datamodel.html#emulating-container-types)

## Simulando un tipo invocable: decoradores con parámetros

Los invocables son aquellos objetos a los que podemos "llamar", es decir,
acompañar de un par de paréntesis con la sintáxis de paso de parámetros que
conocemos. Estos paréntesis con sus parámetros son reamente una invocación
a un método mágico. Esto:

```python
def add(a, b):
    return a + b

add(5, 2)
```

Es en realidad, esto:

```python
functiontype = type(add)
functiontype.__call__(add, 5, 2)
```

El método mágico `__call__` convierte a un objeto en un invocable.

1. Considera la siguiente clase:

    ```python
    class Multiplier:

        def __init__(self, a):
            self.a = a

        def __call__(self, b):
            return self.a * b
    ```

2. La clase `Multiplier` crea multiplicadores. En su inicialización captura
el número por el que multiplicará durante la invocación:

    ```python
    nullify = Multiplier(0)
    once = Multiplier(1)
    double = Multiplier(2)
    triple = Multiplier(3)
    assert nullify(100) == 0
    assert once(100) == 100
    assert double(100) == 200
    assert triple(100) == 300
    ```

    Razona esta sintáxis, también válida:

    ```python
    assert Multiplier(4)(100) == 400
    ```

3. Vamos a utilizar un invocable para simular un decorador con parámetros.
Antes, repasa cómo se hacía con funciones:

    ```python
    # capture the parameters
    def log(tag):
        # capture the function to decorate
        def _decorator(f):
            # capture the orginal arguments of the function
            def _decorated(*args, **kwargs):
                print(f'[{tag}] Calling {f.__name__} with {args} and {kwargs}')
                return f(*args, **kwargs)

            return _decorated

        return _decorator

    @log('test')
    def echo(something):
        return something

    echo(42)
    ```

4. Compara ahora cómo se haría con una clase:

    ```python
    class Log:

        # captures the parameters
        def __init__(self, tag):
            self.tag = tag

        # captures the function
        def __call__(self, f):
            self.f = f
            return self._decorated

        # captures de arguments of the original function
        def _decorated(self, *args, **kwargs):
            f = self.f
            tag = self.tag
            print(f'[{tag}] Calling {f.__name__} with {args} and {kwargs}')
            return f(*args, **kwargs)

    @Log('test')
    def echo(something):
        return something
    ```

5. Convéncete del funcionamiento de la clase utilizando el depurador.

* Documentación de la
[emulación de invocables](https://docs.python.org/3/reference/datamodel.html#emulating-callable-objects)

## Protocolos

### Iteradores

### Generadores

### Contextos

### _Hashables_