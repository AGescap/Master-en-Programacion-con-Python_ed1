# Manejo de archivos y entrada y salida

Ya aprendiste mucho sobre **salida por consola** cuando estudiaste
[cadenas de texto](https://github.com/Fictizia/Master-en-Programacion-con-Python_ed1/blob/master/teoria/b03t01.md#cadenas-de-texto)
y `print` al comienzo del bloque 3.

## Entrada por consola

1. La entrada por consola es también muy sencilla. Se utiliza la función
[`input`](https://docs.python.org/3/library/functions.html#input):

    ```python
    string = input() # will wait for input until pressing enter
    print(f'Entered string is: {string}')
    ```

2. La función `input` puede imprimir un _prompt_, invitando al usuario a
introducir un texto:

    ```python
    string = input('Enter some text and press enter ')
    print(f'Entered string is: {string}')
    ```

3. El resultado de utilizar `input` es un objeto `str`, **siempre**:

    ```python
    string = input('Enter some text and press enter ')
    type(string)
    ```

4. Es nuestra responsabilidad interpretar la entrada de forma que creamos
oportuna. Por ejemplo:

    ```python
    def parse_coordinates(string):
        x, y = string.split()
        return int(x), int(y)

    user_input = input('Enter a 2D coordinate in the form x y: ')
    coordinates = parse_coordinates(user_input)
    print(coordinates)
    ```

5. También es nuestra reponsabilidad reintentar en caso de error:

    ```python
    def parse_coordinates(string):
        x, y = string.split()
        return int(x), int(y)

    while True:
        user_input = input('Enter a 2D coordinate in the form x y: ')
        try:
            coordinates = parse_coordinates(user_input)
        except:
            print('Invalid syntax!')
        else:
            break

    print(coordinates)
    ```

## Ficheros

El manejo de ficheros en Python está en el corazón del lenguaje a través
de la función `open`.

**Importante**: en esta sección vas a crear y manipular ficheros, cuando crees
ficheros o los leas utilizando rutas relativas, estás serán **relativas al
directorio de trabajo** que es el lugar desde el que lanzas el intérprete. Si
lo haces con PyCharm, el directorio de trabajo será aquel donde está el script
que estés ejecutando.

1. Crea un nuevo fichero de texto con `open`:

    ```python
    with open('./data.txt', 'w') as f:
        f.write('Greetings, humans!')
    ```

    Comprueba que el fichero existe en el sistema de archivos y que contiene
    exactamente lo que hemos escrito. Recuerda que se habrá creado en el
    mismo directorio desde el que lanzaste el intérprete.

2. Lee ahora el fichero también con `open`:

    ```python
    with open('./data.txt', 'r') as f:
        print(f.read())
    ```

    La forma más segura y "pitónica" de acceder a un fichero es mediante
    un bloque `with`. El contexto (estudiado durante la lección anterior)
    asegura que, ocurra lo que ocurra durante la ejecución del cuerpo, el
    fichero se cierra correctamente.

3. El primer parámetro de la función `open` es la ruta hasta el fichero. El
segundo es el modo de acceso: `'w'` para escribir y `'r'` para leer. Tratar de
leer en un fichero abierto en modo escritura es un error:

    ```python
    with open('./data.txt', 'w') as f:
        f.read()
    ```

    Prueba a escribir en un archivo abierto en modo lectura y comprueba que
    también es inválido.

4. Abrir un fichero en modo escritura **borra** el contenido anterior. Si
ejecutaste el código del paso anterior, comprueba en el sistema de ficheros
qué le ha pasado al fichero `data.txt`.

5. Restaura los contenidos del fichero.

6. Si quieres abrir un fichero para **añadir información**, utiliza el modo
`'a'`:

    ```python
    with open('./data.txt', 'a') as f:
        f.write('🛸 I am Ziltoid, the omniscient')
    ```

    Comprueba qué has añadido la nueva cadena de caracteres al fichero. Si todo
    ha ido bien, la cadena se habrá añadido **justo a continuación** del
    contenido anterior.

7. Puedes abrir un fichero en modo "lectura y escritura":

    ```python
    with open('./data.txt', 'r+') as f:
        text = f.read()
        f.write('\n' + text.upper())
    ```

    En el modo `'r+'`, el fichero no se vacía primero.

8. Otra forma de abrir un fichero en modo "lectura y escritura" es:

    ```python
    with open('./data.txt', 'w+') as f:
        text = f.read()
        assert len(text) == 0
    ```

    En el modo `'w+'`, el fichero se trunca al abrirse.

### Modos de apertura

Existen otros modos de abrir un archivo que puedes explorar, combinables
hasta cierto punto:

| Carácter/Combinación   | Significado                                        |
|------------------------|----------------------------------------------------|
| `'r'`  | Abiero para lectura (por defecto).                                 |
| `'w'`  | Abierto para escritura, vacía el fichero si ya existe.             |
| `'x'`  | Abierto para creación exclusiva; si ya existe, falla.              |
| `'a'`  | Abierto para escritura, añade al final si ya existe.               |
| `'b'`  | Abierto en modo binario, `read` y `write` trabajan con `bytes`.    |
| `'t'`  | Abierto en modo texto (por defecto).                               |
| `'+'`  | Abierto para lectura y escritura.                                  |
| `'r+'` | Abierto para lectura y escritura, añade al final si ya existe.     |
| `'w+'` | Abierto para lectura y escritura, vacía el fichero si ya existe.   |

### Codificación

Como puedes comprobar, por defecto `open` trabaja con ficheros de texto. Pero
como ya estudiaste, un fichero de texto sólo guarda bytes que representan texto
en alguna codificación. Podemos indicar la codificación a utilizar pasando
el parámetro `encoding` a `open`:

```python
with open('./data.txt', 'w+', encoding='utf8') as f:
    text = """Greetings humans!
🛸 I am Ziltoid, the omniscient."""
    f.write(text)
```

Con esto nos aseguramos que el fichero tiene codificación UTF-8. Si no se
especifica ninguna, la codificación por defecto se obtiene del sistema,
mediante:

```python
import locale
locale.getpreferredencoding(False)
```

El acceso a ficheros en modo texto es, con diferencia, más lento que el acceso
binario del que hablaremos un poco más adelante pero ofrece muchas
conveniencias para manejar texto.

### Leyendo línea a línea

En modo texto, podemos leer línea a línea o iterar por las líneas de un fichero:

1. Para leer las líneas explícitamente, utilizamos:

    ```python
    with open('./data.txt', 'r') as f:
        while True:
            line = f.readline()
            if not line:
                break
            print(line)
    ```

2. Para iterar sobre las líneas hacemos:

    ```python
    with open('./data.txt', 'r') as f:
        for line in f:
            print(line)
    ```

* Documentación de los objetos devueltos por `open` en
[modo texto](https://docs.python.org/3/library/io.html#io.TextIOWrapper)

### Trabajo con ficheros binarios

Los ficheros binarios están a la orden del días: imágenes, ficheros de audio,
ejecutables, archivos comprimidos...

Cuando se trabaja con ficheros binarios, pasando el modo `'b'`, los métodos
de lectura y escritura como `write`, `read` dejan de aceptar cadenas (`str`)
y sólo aceptan cadenas de bytes (`bytes`).

Sin embargo, la gestión de tales cadenas de bytes y su significado, queda
totalmente bajo nuestra responsabilidad. Como ejemplo, vamos a crear un formato
que permita crear listas de puntos 2D con coordenadas comprendidas entre
0 y 255.

1. Crea la función que convierte puntos (tuplas de dos elementos) a bytes
&mdash;el **serializador**&mdash;:

    ```python
    def serialize_point(p):
        if not isinstance(p, tuple) or len(p) != 2:
            raise ValueError('can only serialize tuples of two integers')

        x, y = p
        return serialize_byte(x) + serialize_byte(y)

    def serialize_byte(n):
        if not isinstance(n, int) and (n < 0 or n > 255):
            raise ValueError('can only serialize integers in the range [0, 255]')

        return bytes([n])
    ```

2. Crea la función que convierte listas de puntos a bytes:

    ```python
    def serialize_point_list(point_list):
        if len(point_list) > 255:
            raise ValueError('cannot serialize lists bigger than 255 elemnts')

        bytes_ = bytearray([len(point_list)])
        for point in point_list:
            bytes_ += serialize_point(point)
        return bytes(bytes_)
    ```

    La representación es el número de elemntos (de 0 a 255), seguido de los
    elementos.

3. Ahora podemos escribir estos bytes en un fichero binario:

    ```python
    with open('./test.points', 'wb') as f:
        list_of_points = [(0, 0), (10, 20), (254, 30)]
        f.write(serialize_point_list(list_of_points))
    ```

    Comprueba que el fichero se ha creado correctamente e intenta abrirlo
    con un editor de texto. Sólo verás unos símbolos extraños, muestra de que
    estamos ante un fichero binario.

Vamos a leerlo.

1. Crea la función que convierte bytes a puntos (tuplas) &mdash;el
deserializador&mdash;:

    ```python
    def deserialize_point(bytes_):
        if len(bytes_) > 2:
            raise ValueError('point is bad formed')

        x, y = bytes_
        return x, y
    ```

2. Ahora crea el deserializador de listas de puntos:

    ```python
    def deserialize_point_list(bytes_):
        if len(bytes_) < 1:
            raise ValueError('the list of points is bad formed')

        l = bytes_[0]
        points = bytes_[1:]
        if len(points) != l * 2:
            raise ValueError('the list of points is bad formed')

        list_of_points = []
        for i in range(0, len(points), 2):
            point_bytes = points[i:i+2]
            list_of_points.append(deserialize_point(point_bytes))

        return list_of_points
    ```

3. Ahora leemos el archivo en modo binario:

    ```python
    with open('./test.points', 'rb') as f:
        data = f.read()
        list_of_points = deserialize_point_list(data)
        assert list_of_points == [(0, 0), (10, 20), (254, 30)]
    ```

* Documentación de los objetos devueltos por `open` en
[modo binario](https://docs.python.org/3/library/io.html#io.BufferedIOBase)

#### Relación entre el modo de texto y el modo binario

Cuando Python abre un fichero en modo texto, realmente lo abre en modo binario
pero le añade una capa de codificación/decodificación por encima.

Para acceder al objeto binario subyacente, podemos hacer:

```python
with open('./data.txt', 'r') as f:
    character_count = len(f.read())
    underlying_binary_buffer = f.buffer
    underlying_binary_buffer.seek(0) # set the read cursor at the beginning
    byte_count = len(underlying_binary_buffer.read())
    print(f'Char count: {character_count}, Byte count: {byte_count}')
```
¿Por qué hay más bytes que caracteres?

### Persistencia de datos

Afortunadamente, serializar y deserializar

### Usar cadenas de texto como ficheros

## Entrada, salida y error estándares