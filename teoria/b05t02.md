# Patrones de diseño

Los patrones de diseño son soluciones a problemas repetitivos en el desarrollo
del software. Los patrones de diseño se pusieron de moda tras la publicación
del libro
[_Design Patterns: Elements of Reusble Object-Oriented Software_](https://en.wikipedia.org/wiki/Design_Patterns_(book)) de la llamada _gang of four_ (Erich Gamma,
Richard Helm, Ralph Johnson and John Vlissides).

En su libro, los autores organizan los patrones de diseño en tres categorías:

* Patrones de creación.
* Patrones estructurales.
* Patrones de comportamiento.

Se proporcionan ejemplos de cada uno en C++ y Smalltalk.

Hay que aproximar los patrones de diseño con cierta cautela, pensando en
que algunos se pensaron para solventar carencias de los lenguajes de la época.

Los patrones nos proporcionan, a los desarrolladores, **un vocabulario común
con el que referirnos a ciertas construcciones** pero no dejan de ser
herramientas de un dominio y primero hemos de identificar si el problema al
que nos aproximamos es adecuado para el uso de tales herramientas.

A continuación se discuten las versiones en Python de algunos de los patrones
del _gang of four_.

## _Singleton_

Surge para modelar la usual situación de tipos de un sólo valor (o de valores
limitados, [en una de sus variantes](https://en.wikipedia.org/wiki/Multiton_pattern)).

Suelen codificar sistemas, como "el sistema de ficheros", o "el sistema de
video", pero no está limitado a ello. En Python, `None` and `...` son
_singletons_.

La forma de implementar un _singleton_ en Python es sobreescribiendo el
constructor de la clase `__new__`:

```python
class FileSystem:

    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(FileSystem, *args, **kwargs)

        return cls._instance
```

El método de clase `__new__` está encargado de construir los objetos de la
clase. No necesita el decorador `@classmethod` porque Python lo reconoce
por el nombre. La implementación en la clase `object` es código del intérprete
que se encarga de reservar la memoria adecuada para crear un objeto. Los
parámetros que recibe son la clase (como cualquier otro método de clase) y
aquellos que se pasaron a la clase, en la expresión de construcción.

Esta implementación del constructor de la clase limita su efecto a una sola
ocasión, puesto que `if cls._instance is None` sólo puede ser `True` una vez.
El resto de las veces, en lugar de llamarse al constructor por defecto, se
devolverá el ejemplar en `cls._instance`.

Comprueba la unicidad del singleton:

```python
f = FileSystem()
g = FileSystem()
f is g
```

## Método factoría (_factory method_)

Conviene observar este patrón analizando primero la función factoría: una
función encargada de crear objetos. Eso permite, al usuario de un tipo, evitar
el uso de una clase concreta para construir el valor que necesita.

Has utilizado una función factoría para producir _loggers_ durante el tema
de registro de eventos:

```python
import logging
logger = logging.getLogger('headquarter.defenses')
```

El módulo `logging` utiliza la función `getLogger` para construir un _logger_
y añadirlo a una jerarquía de _loggers_ de la que el objeto _logger_ puede
que no sepa nada.

Considera el manejo de un sistema crítico. Queremos que, cada vez que creemos
una medida de seguridad, dejemos registrado un suceso que lo refleje, para
futuras auditorías. Podríamos hacer:

```python
import logging

class SecurityMeasure:

    def __init__(self):
        logging.warning('New security measure created')

s = SecurityMeasure()
```

Sin embargo, no parece que "dejar un mensaje" sea una de las responsabilidades
de `SecurityMeasure`. Podemos obtener una mejor solución con:

```python
class SecurityMeasure:
    ...

def new_security_measure(*args, **kwargs):
    logging.warning('New security measure created')
    return SecurityMeasure(*args, **kwargs)

s = new_security_measure()
```

Conocido el rol de una función factoría, podemos combinar su potencia con la
herencia para crear jerarquías en las que las clases base delegan la creación
de los objetos que utilizan en las clases derivadas:

```python
from abc import ABC, abstractmethod

class PirateCaptain(ABC):

    def __init__(self):
        self._ship = self.make_ship()

    def sailor(self):
        print(f'Navigating aboard a {self._ship}')

    def make_ship(self):
        raise NotImplementedError

class SpacePirate(PirateCaptain):

    def make_ship(self):
        return SpaceShip()

class CaribbeanSeaPirate(PirateCaptain):

    def make_ship(self):
        return Galleon()

class SpaceShip:
    ...

class Galleon:
    ...

harlock = SpacePirate()
harlock.sailor()
sparrow = CaribbeanSeaPirate()
sparrow.sailor()
```

He ahí una implementación del principio "abierto para extensión/cerrado para
modificación" ejemplar.

## _Builder_

El patrón _builder_ simplifica la creación de objetos complejos proporcionando
una interfaz más ergonómica. Además separa la forma de suministrar las partes
constituyentes de un objeto de la representación interna por lo que tiene
aplicaciones similares a las de la función factoría.

Considera, por ejemplo, la construcción de peticiones de bases de datos:

```python
from abc import ABC, abstractmethod

class DBQuery(ABC):

    def __init__(self, table, fields, where, order_by):
        self._table = table
        self._fields = fields
        self._where = where
        self._order_by = order_by

    @abstractmethod
    def execute(self):
        raise NotImplementedError

class SQLQuery(DBQuery):

    def execute(self):
        output = [f'SELECT {", ".join(self._fields)} FROM {self._table}']
        if self._where:
            output += [f'WHERE {self._where}']
        if self._order_by:
            output += [f'ORDER BY {self._order_by}']

        print('Running', ' '.join(output))

class QueryBuilder:

    def select(self, *fields):
        if not fields or fields[0] == '*':
            self._fields = ['*']
        else:
            self._fields = fields

        return self

    def from_table(self, tablename):
        self._tablename = tablename
        return self

    def where(self, condition):
        self._where_condition = condition
        return self

    def order_by(self, order):
        self._order_by = order
        return self

    def assemble(self):
        return SQLQuery(
            self._tablename, self._fields,
            self._where_condition, self._order_by)

foreign_participants = QueryBuilder()\
    .select('name', 'country')\
    .from_table('participants')\
    .where('country != "Spain"')\
    .order_by('country ASC')\
    .assemble()

foreign_participants.execute()
```

Si en un momento dado, quisiéramos cambiar el motor de persistencia de nuestra
aplicación a Mongo, bastaría con cambiar la implementación del método
`assemble` para que usara una hipotética clase `Mongo`. Queda como ejercicio
proporcionar la clase `MongoQuery` que represente correctamente en mongo
la petición anterior.

* [Equivalencia entre SQL y Mongo](https://docs.mongodb.com/manual/reference/sql-comparison/)

## Fachada (_façade_)

Una fachada es una API que **homogeniza funcionalidad de otras APIs**.
Por ejemplo, imagina que estás creando una utilidad para encontrar todas las
imágenes de un directorio. Tu código puede lucir tal que así:

```python
import os

def find_images(root):
    all_images = set()
    for dirname, dirs, files in os.walk(root):
        for one_file in files:
            if os.path.splitext(one_file)[1] in ['.jpg', '.png', '.gif', '.bmp']:
                file_path = os.path.join(root, dirname, one_file)
                all_images.add(file_path)

    return all_images
```

Una reimplementación del código anterior, haciendo uso de una fachada que
unificara e incluso, simplificara la funcionalidad relacionada con el sistema
de archivos podría ser:

```python
import os

class FileSystem:

    def extension(self, item):
        return os.path.splitext(item)[1]

    def walk(self, dirname):
        return os.walk(dirname)

    def join(self, path, *paths):
        return os.path.join(path, *paths)

fs = FileSystem()

def find_images(root):
    all_images = set()
    for dirname, dirs, files in fs.walk(root):
        for one_file in files:
            if fs.extension(one_file) in ['.jpg', '.png', '.gif', '.bmp']:
                file_path = fs.join(root, dirname, one_file)
                all_images.add(file_path)

    return all_images
```

## Adaptador (_adapter_)

Un adaptador expone una funcionalidad a través de una interfaz objetivo. La
**funcionalidad expuesta es adaptada a la API objetivo**.

El problema de adaptar una API se da, muy a menudo y de forma natural cuando
evolucionamos un software. Por ejemplo, imagina que estás desarrollando una
utilidad para la encontrar todas las imágenes de un sistema de archivos.

Es muy probable que tu API de referencia sea aquella que suministra Python en
los módulos `os` y `os.path` . Por ejemplo:

```python
import os
import os.path

class FileSystem:

    def extension(self, item):
        return os.path.splitext(item)[1]

    def walk(self, dirname):
        return os.walk(dirname)

    def join(self, path, *paths):
        return os.path.join(path, *paths)

def find_images(root):
    all_images = set()
    fs = FileSystem()
    for dirname, dirs, files in fs.walk(root):
        for one_file in files:
            if fs.extension(one_file) in ['.jpg', '.png', '.gif', '.bmp']:
                file_path = fs.join(root, dirname, one_file)
                all_images.add(file_path)

    return all_images
```

Sin embargo, si ahora quisiéramos encontrar las imágenes en una carpeta de
Google Drive, podríamos darnos cuenta de que algunas operaciones no están en
la biblioteca de Google Drive para Python.

Imaginemos, por ejemplo, que las únicas operaciones disponibles fueran:

```python
class GoogleDriveAPI:

    def get_items(self, path):
        """Return the names of the items in the path."""

    def item_type(self, itempath):
        """Return the type of the item at ``itempath``: 'f' or 'd'."""
```

Intentando modificar lo menos posible el código de `find_images`, podríamos
creae el adaptador:

```python
class GoogleDriveFileSystem(FileSystem):

    def __init__(self):
        self._api = DriveAPI()

    def walk(self, dirname):
        if self._api(dirname) != 'folder':
            raise ValueError('the path must be a folder')

        subdir = ''
        remaining_dirs = ['']
        while remaining_dirs:
            subdir = self._api.join(subdir, remaining_dirs.pop(0))
            dirs, files = self._get_dirs_and_files(dirname, subdir)
            remaining_dirs += dirs
            yield subdir, dirs, files

    def _get_dirs_and_files(self, dirname, subdir):
        dirs, files = [], []
        dirpath = self._api.join(dirname, subdir)
        for item in self._api.get_items(dirpath):
            itempath = self._api.join(dirpath, item):
            if self._api.get_type(itempath) == 'd':
                dirs.append(item)
            else:
                files.append(item)

        return dirs, files
```

## Objeto compuesto (_composite_)

Un objeto compuesto es un árbol, un grafo o alguna estructura donde los
**elementos compuestos y los componentes comparten una API común**. Por
ejemplo, considera una API gráfica:

```python
from abc import ABC, abstractmethod

class Graphic(ABC):

    @abstractmethod
    def draw(self):
        raise NotImplementedError


class Triangle(Graphic):

    def draw(self):
        print('Drawing a triangle')

class Square(Graphic):

    def draw(self):
        print('Drawing a square')

class CompositeGraphic(Graphic):

    def __init__(self):
        self._graphics = set()

    def add(self, graphic):
        self._graphics.add(graphic)

    def draw(self):
        for graphic in self._graphics:
            graphic.draw()

house = CompositeGraphic()
house.add(Triangle())
house.add(Square())
house.draw()
```

## Proxy

Un objeto proxy es un **representante de otro objeto**. Este representante
comparte la interfaz del objeto al que representa pero opera de manera
ligeramente distinta.

Por ejemplo, la mayoría de bibliotecas que dan acceso a APIs de Internet
son proxies, puesto que no realizan lógica de negocio sino que envían mensajes
a los verdaderos objetos en el servidor:

```python
class Post:

    def __init__(self, slug):
        self._slug = slug

    def save(self):
        payload = f'{{ "title":"{self.title}", "body":"{self.body}" }}'
        print(f'Sending: POST mysite.com/api/posts/{self._slug}/ {payload}')

    def delete(self):
        print(f'Sending: DELETE mysite.com/api/posts/{self._slug}/')

p = Post('space-opera')
p.title = 'The Hitchhiker\'s Guide to the Galaxy'
p.body = 'One of my favourite genres in literature is scy-fi...'

p.save()
p.delete()
```

## Decorador (_decorator_)

Un decorador es un objeto que **extiende la funcionalidad de otro**, sin
alterar otras instancias de la misma clase.

Este es uno de esos patrones innecesarios en Python, que tiene soporte para
decoradores de métodos y clases directamente y dónde modificar una instancia
en concreto puede llevarse a cabo modificando su propiedad `__dict__`.

## Observer

```python
class Observable:

    def __init__(self):
        self._observers = []

    def add_observer(self, handle):
        self._observers.append(handle)

    def click(self):
        self._notify()

    def _notify(self):
        for handle in self._observers:
            handle()

    def get_state(self):
        return self._clicked_events


class LazyObserver:
    def __init__(self, observable):
        self._observers = []
        self._observable = observable

    def add_observer(self, handle):
        self._observers.append(handle)

    def update(self):
        self._notify()

    def _notify(self):
        state = self._observable.get_state()
        for handle in self._observers:
            handle(state)


def log_click():
    print('click!')

def open_window():
    print('window open')

def do_business():
    print('cosas Nazis, Peter')

o = Observable()
o.add_observer(log_click)
o.add_observer(open_window)
o.add_observer(do_business)

o.click()

class Profile:

    ...
```

## Visitor

```python
class dict_values:

    def __init__(self, something):
        self._visitable = something

    def __iter__(self):
        for value in self._visitable.__dict__.values():
            yield value


class filtered_dict_values_per_key:

    def __init__(self, filter, something):
        self._filter = filter
        self._visitable = something

    def __iter__(self):
        something = self._visitable
        for value in filter(lambda p: self._filter(p[0]), something.__dict__.items()):
            yield value[1]


class Visitable:

    def accept(self, visitor):
        yield from visitor.visit(self)


v = Visitable()
v.a = 1
v.b = 2
v.z = 3
v.zz = 4

for value in filtered_dict_values_per_key(lambda k: k[0] == 'z', v):
    print(value)
```

## Command

```python
def turn_right_finder(maze, start_point, exit_point, give_up):
    current_point = start_point
    while maze.is_exit_point(current_point):
        current_point = maze.get_next_position(current_point, 'e')


class Maze:

    def solve(self, strategy, give_up):
        return strategy.solve(self, self._enter_point, self._exit_point, give_up)


class Adder:

    def __init__(self, addition):
        self._addition = addition

    def __call__(self, param):
        return self._addition + param


add5 = Adder(5)
add5(6)


m = Maze()
m.solve(turn_right_finder)
```

## Strategy