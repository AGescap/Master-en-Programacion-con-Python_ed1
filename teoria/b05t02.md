# Patrones de diseño

Los patrones de diseño son soluciones a problemas repetitivos en el desarrollo
del software. Los patrones de diseño se pusieron de moda tras la publicación
del libro
[_Design Patterns: Elements of Reusble Object-Oriented Software_](https://en.wikipedia.org/wiki/Design_Patterns_(book)) de la llamada _gang of four_ (Erich Gamma,
Richard Helm, Ralph Johnson and John Vlissides).

En su libro, los autores organizan los patrones de diseño en tres categorías:

* Patrones de creación.
* Patrones estructurales.
* Patrones de comportamiento.

Se proporcionan ejemplos de cada uno en C++ y Smalltalk.

Hay que aproximar los patrones de diseño con cierta cautela, pensando en
que algunos se pensaron para solventar carencias de los lenguajes de la época.

Los patrones nos proporcionan, a los desarrolladores, **un vocabulario común
con el que referirnos a ciertas construcciones** pero no dejan de ser
herramientas de un dominio y primero hemos de identificar si el problema al
que nos aproximamos es adecuado para el uso de tales herramientas.

A continuación se discuten las versiones en Python de algunos de los patrones
del _gang of four_.

## _Singleton_

Surge para modelar la usual situación de tipos de un sólo valor (o de valores
limitados, [en una de sus variantes](https://en.wikipedia.org/wiki/Multiton_pattern)).

Suelen codificar sistemas, como "el sistema de ficheros", o "el sistema de
video", pero no está limitado a ello. En Python, `None` and `...` son
_singletons_.

La forma de implementar un _singleton_ en Python es sobreescribiendo el
constructor de la clase `__new__`:

```python
class FileSystem:

    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(FileSystem, *args, **kwargs)

        return cls._instance
```

El método de clase `__new__` está encargado de construir los objetos de la
clase. No necesita el decorador `@classmethod` porque Python lo reconoce
por el nombre. La implementación en la clase `object` es código del intérprete
que se encarga de reservar la memoria adecuada para crear un objeto. Los
parámetros que recibe son la clase (como cualquier otro método de clase) y
aquellos que se pasaron a la clase, en la expresión de construcción.

Esta implementación del constructor de la clase limita su efecto a una sola
ocasión, puesto que `if cls._instance is None` sólo puede ser `True` una vez.
El resto de las veces, en lugar de llamarse al constructor por defecto, se
devolverá el ejemplar en `cls._instance`.

Comprueba la unicidad del singleton:

```python
f = FileSystem()
g = FileSystem()
f is g
```

## Método factoría (_factory method_)

Conviene observar este patrón analizando primero la función factoría: una
función encargada de crear objetos. Eso permite, al usuario de un tipo, evitar
el uso de una clase concreta para construir el valor que necesita.

Has utilizado una función factoría para producir _loggers_ durante el tema
de registro de eventos:

```python
import logging
logger = logging.getLogger('headquarter.defenses')
```

El módulo `logging` utiliza la función `getLogger` para construir un _logger_
y añadirlo a una jerarquía de _loggers_ de la que el objeto _logger_ puede
que no sepa nada.

Considera el manejo de un sistema crítico. Queremos que, cada vez que creemos
una medida de seguridad, dejemos registrado un suceso que lo refleje, para
futuras auditorías. Podríamos hacer:

```python
import logging

class SecurityMeasure:

    def __init__(self):
        logging.warning('New security measure created')

s = SecurityMeasure()
```

Sin embargo, no parece que "dejar un mensaje" sea una de las responsabilidades
de `SecurityMeasure`. Podemos obtener una mejor solución con:

```python
class SecurityMeasure:
    ...

def new_security_measure(*args, **kwargs):
    logging.warning('New security measure created')
    return SecurityMeasure(*args, **kwargs)

s = new_security_measure()
```

Conocido el rol de una función factoría, podemos combinar su potencia con la
herencia para crear jerarquías en las que las clases base delegan la creación
de los objetos que utilizan en las clases derivadas:

```python
from abc import ABC, abstractmethod

class PirateCaptain(ABC):

    def __init__(self):
        self._ship = self.make_ship()

    def sailor(self):
        print(f'Navigating aboard a {self._ship}')

    def make_ship(self):
        raise NotImplementedError

class SpacePirate(PirateCaptain):

    def make_ship(self):
        return SpaceShip()

class CaribbeanSeaPirate(PirateCaptain):

    def make_ship(self):
        return Galleon()

class SpaceShip:
    ...

class Galleon:
    ...

harlock = SpacePirate()
harlock.sailor()
sparrow = CaribbeanSeaPirate()
sparrow.sailor()
```

He ahí una implementación del principio "abierto para extensión/cerrado para
modificación" ejemplar.

## _Builder_

El patrón _builder_ simplifica la creación de objetos complejos proporcionando
una interfaz más ergonómica. Además separa la forma de suministrar las partes
constituyentes de un objeto de la representación interna por lo que tiene
aplicaciones similares a las de la función factoría.

Considera, por ejemplo, la construcción de peticiones de bases de datos:

```python
from abc import ABC, abstractmethod

class DBQuery(ABC):

    def __init__(self, table, fields, where, order_by):
        self._table = table
        self._fields = fields
        self._where = where
        self._order_by = order_by

    @abstractmethod
    def execute(self):
        raise NotImplementedError

class SQLQuery(DBQuery):

    def execute(self):
        output = [f'SELECT {", ".join(self._fields)} FROM {self._table}']
        if self._where:
            output += [f'WHERE {self._where}']
        if self._order_by:
            output += [f'ORDER BY {self._order_by}']

        print('Running', ' '.join(output))

class QueryBuilder:

    def select(self, *fields):
        if not fields or fields[0] == '*':
            self._fields = ['*']
        else:
            self._fields = fields

        return self

    def from_table(self, tablename):
        self._tablename = tablename
        return self

    def where(self, condition):
        self._where_condition = condition
        return self

    def order_by(self, order):
        self._order_by = order
        return self

    def assemble(self):
        return SQLQuery(
            self._tablename, self._fields,
            self._where_condition, self._order_by)

foreign_participants = QueryBuilder()\
    .select('name', 'country')\
    .from_table('participants')\
    .where('country != "Spain"')\
    .order_by('country ASC')\
    .assemble()

foreign_participants.execute()
```

Si en un momento dado, quisiéramos cambiar el motor de persistencia de nuestra
aplicación a Mongo, bastaría con cambiar la implementación del método
`assemble` para que usara una hipotética clase `Mongo`. Queda como ejercicio
proporcionar la clase `MongoQuery` que represente correctamente en mongo
la petición anterior.

* [Equivalencia entre SQL y Mongo](https://docs.mongodb.com/manual/reference/sql-comparison/)

## Adapter

```python
import os.path
import os

class FileSystem:

    def stat(self, item):
        return os.stat(item)

    def walk(self, dirname):
        return os.walk(dirname)

    def join(self, *parts):
        return os.path.join(*parts)


class DriveAPI:

    def get_items(self, path):
        ...

    def item_type(self, item):
        ...


class DriveFileSystem:

    def __init__(self):
        self._api = DriveAPI()


    def stat(self, item):
        return self._api.item_type(item)

    def walk(self, dirname):
        is_folder = self._api(dirname) == 'folder'
        if not is_folder:
            raise ValueError('the path must be a folder')

        while True:
            items = self._api.get_items(dirname)
            yield items
            dirs = self._getdirs(items)
            for dirname in dirs:


        return os.walk(dirname)

    def join(self, *parts):
        return  '/'.join(parts)
```

## Façade

## Observer

```python
class Observable:

    def __init__(self):
        self._observers = []

    def add_observer(self, handle):
        self._observers.append(handle)

    def click(self):
        self._notify()

    def _notify(self):
        for handle in self._observers:
            handle()

    def get_state(self):
        return self._clicked_events


class LazyObserver:
    def __init__(self, observable):
        self._observers = []
        self._observable = observable

    def add_observer(self, handle):
        self._observers.append(handle)

    def update(self):
        self._notify()

    def _notify(self):
        state = self._observable.get_state()
        for handle in self._observers:
            handle(state)


def log_click():
    print('click!')

def open_window():
    print('window open')

def do_business():
    print('cosas Nazis, Peter')

o = Observable()
o.add_observer(log_click)
o.add_observer(open_window)
o.add_observer(do_business)

o.click()

class Profile:

    ...
```

## Visitor

```python
class dict_values:

    def __init__(self, something):
        self._visitable = something

    def __iter__(self):
        for value in self._visitable.__dict__.values():
            yield value


class filtered_dict_values_per_key:

    def __init__(self, filter, something):
        self._filter = filter
        self._visitable = something

    def __iter__(self):
        something = self._visitable
        for value in filter(lambda p: self._filter(p[0]), something.__dict__.items()):
            yield value[1]


class Visitable:

    def accept(self, visitor):
        yield from visitor.visit(self)


v = Visitable()
v.a = 1
v.b = 2
v.z = 3
v.zz = 4

for value in filtered_dict_values_per_key(lambda k: k[0] == 'z', v):
    print(value)
```

## Command

```python
def turn_right_finder(maze, start_point, exit_point, give_up):
    current_point = start_point
    while maze.is_exit_point(current_point):
        current_point = maze.get_next_position(current_point, 'e')


class Maze:

    def solve(self, strategy, give_up):
        return strategy.solve(self, self._enter_point, self._exit_point, give_up)


class Adder:

    def __init__(self, addition):
        self._addition = addition

    def __call__(self, param):
        return self._addition + param


add5 = Adder(5)
add5(6)


m = Maze()
m.solve(turn_right_finder)
```

## Strategy