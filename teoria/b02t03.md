# Olores del código y refactorización

Los olores en el código son **indicativos de que un diseño falla** o va en 
contra de los principios de diseño de software, lo que suele desenvocar en 
**software menos tolerantes al cambio y más frágil**.

El término fue acuñado por [Kent Beck](https://en.wikipedia.org/wiki/Kent_Beck)
y popularizado por [Martin Fowler](https://en.wikipedia.org/wiki/Martin_Fowler_%28software_engineer%29)
en su libro [_Refactoring_](https://www.amazon.es/dp/0134757599/ref=pd_lpo_sbs_dp_ss_1).

_Refactorizar_ es el proceso de reescribir código con el objetivo de **mejorar 
el diseño**, y no de alterar el comportamiento del programa. Las técnicas de 
refactorización se podrían clasificar en:

* Renombramientos.
* Cambios de lugar.
* Introducción de nuevas abastracciones.
* Eliminación de abstracciones innecesarias.

## Olores de implementación

Son los que emergen del código confuso, difícil de leer y de entender.

### El nombre misterioso

El nombre de una función, de una clase o de una variable debería sugerir **qué 
hace, qué representa o qué contiene**. Se arregla con un **renombramiento**.

1. Considera el siguiente código:

    ```python
    def dijkstra_algorithm(graph):
       ...
    ```
    
    ¿Para qué crees que sirve este algoritmo?
    
2. Busca quién era Dijkstra y qué hace su algoritmo y sugiere un mejor nombre.

### Código duplicado

El código duplicado crea incertidumbre acerca de si las distintas apariciones
son, en efecto, la misma, o si se trata de un error. Se solventa 
**introduciendo una función** y **moviendo el código común** a su interior.

1. Considera el siguiente fragmento:

    ```python
    class HttpChat:
 
       def __init__(self, url):
           self._url = url

       def login(self, user, password):
           message = Message(f'LOGIN {user}:{password}')
           message.send(self._url)
           message.wait_for_response()
           return message.response()
        
       def send(self, what):
           message = Message(f'SEND {what}')
           message.send(self._url)
           message.wait_for_response()
           return message.response()
        
       def answer(self, message_id, what):
           message = Message(f'ANSWER {what} TO {message_id}')
           message.send(self._url)
           message.wait_for_response()
           return message.response()
        
       def keep_alive(self):
           message = Message(f'I AM STILL HERE')
           message.send(self._url)
 
    ``` 
    
    ¿Dónde se repite el código?
    
2. Refactoriza el código para que no haya tanta repetición.

### La función larga

A veces una función hace demasiadas cosas, lo que provoca que tenga **muchas 
motivos de cambio**, que no quepa en pantalla o que haya que **leerla varias
veces**. Se suele arreglar **dividiendo la función en otras más cortas**.

1. Considera el siguiente código:

    ```python
    def count(text, exclusion_list):
       if not isinstance(text, str):
           raise TypeError('text must be a string')
       
       words = text.split()
       valid_words = (w for w in words if w not in exclusion_list)
       histogram = {}
       for word in valid_words:
           if word not in histogram:
               histogram[word] = 0
            
           histogram[word] += 1
        
       return histogram
    ```
    
   ¿Podrías indicar qué hace `count` añadiendo algunos comentarios?
   
2. Reemplaza cada comentario y código asociado por una llamada a una función 
distinta.

### Bucles

### Comentarios

## Olores del diseño

Son los que emergen de diseños ineficaces: demasiado rígidos, demasiado 
interdependientes y por tanto, más frágiles.

### Cambio por más de una razón (_divergent change_)

Un módulo o una clase cambia por más de una razón. Esto va **directamente en 
contra del principio de única responsabilidad** del que hablábamos en el 
capítulo acerca de SOLID. Se dividiendo la clases por los "motivos de
cambio" en otras .

### La gran clase

### El cambio-escopeta (_shotgun surgery_)

Hace referencia a un cambio, en principio pequeño, que **desencadena multitud 
de cambios menores** en todas partes, como si se tratara de la dispersión de 
los perdigones tras el disparo de una escopeta. Se arregla haciendo que **las 
cosas que cambian juntas, estén juntas**.

### Grupos de datos

Se refiere a conjuntos de datos que **suelen ir juntos o se tratan siempre de 
la misma manera**. Se da esta situación es normamente porque los tratamos 
como si fueran una unidad. En tal caso es mejor agruparlos en una 
abstracción y eliminar, de paso, código duplicado.

1. Echa un vistazo al siguiente fragmento:

    ```python
    class Player:
 
       def __init__(self):
           self.reset()

       def move(self, direction_x, direction_y, direction_z):
           self.x += direction_x
           self.y += direction_y
           self.z += direction_z
        
       def teleport(self, new_x, new_y, new_z):
           self.x = new_x
           self.y = new_y
           self.z = new_z
  
       def reset(self):
           self.x = 0
           self.y = 0
           self.z = 0
    ```
    
    ¿Qué concepto crees que falta?

2. Crea una clase que represente los conceptos que falten.

### Listas larga de parámetros

Las listas largas de parámetros son, muchas veces, una ocurrencia particular de 
los **grupos de datos**. Hacen la lectura de las llamadas a funciones, 
**confusa**. Se arreglan introduciendo abstracciones. 

1. Considera el siguiente código:

    ```python
    def send_message(msg, protocol, where, port, user, password):
       print(f'SENDING {msg} TO {protocol}://{where}:{port} BY {user}:{password}')
    
    msg = 'Greetings, humans. I\'m Ziltoid, the Omniscient.'
    send_message(msg, 'http', 'test.com', 8080, 'salva', '123')
    ```
    
    ¿Qué parámetros crees que están más relacionados entre sí?

2. Crea una clase que represente los parámetros que consideren que deban ir 
juntos y cambia la función `send_message` para que opere con la nueva 
abstracción.

### Obsesión con los tipos primitivos

### Datos mutables

La mutabilidad introduce nuevas fuentes de preocupación sobre la coherencia y
la secuencia y hace más **difícil razonar sobre los datos**, que pueden 
significar cosas distintas, dependiendo del momento del programa. Se arregla 
aplicando **inmutabilidad por defecto**.

1. Considera el siguiente fragmento:

    ```python
    class HTTPRequest:

        def __init__(self):
            self.url: str = None
            self._state = 'NEW'
    
        def open(self, url: str) -> None:
            assert self._state == 'NEW', 'state of the request is invalid'
            self.url = url
            print(f'Connecting to {url}')
            self._state = 'OPEN'
    
        def send(self, method: str) -> None:
            assert self._state == 'OPEN', 'state of the request is invalid'
            accepted = ['GET', 'POST']
            if method.upper() not in accepted:
                raise RuntimeError(f'method must be one of {accepted}')
            print(f'Sending {method.upper()}')
            self._state = 'SENT'
         
    if __name__ == '__main__':
       request = HTTPRequest()
       request.open('http://test.com')
       request.send('GET')
       request.send('POST')
       request.open('http://another-endpoint.com')
    ```
    
    Explícale a un compañero por qué falla el listado anterior.
    
2. ¿Se te ocurre cómo solucionarías este problema? Pista: puedes crear 
 nuevas clases.
 
### Datos globales

A los problemas de los datos mutables, se le une que ahora la modificación 
puede realizarse **desde cualquier punto del programa**.

### Sobreingeniería (_speculative generality_)

## Más olores

Esta lista es incompleta. Entrenaremos nuestra nariz y descubriremos más 
olores en el código cuando avancemos por el curso y nos pongamos a escribir 
Python, de verdad.  

Los olores en el código se relacionan con los
[anti-patrones](https://en.wikipedia.org/wiki/Anti-pattern) en que estos 
últimos suelen "oler". Un anti-patrón es una solucción recurrente a un 
problema que, usualmente, conlleva un **diseño deficiente, inefectivo y 
contraproducente** a largo plazo.

El capítulo 3 del libro de Fowler contiene los tipos de olores identificados 
por el autor. Los mismos pueden encontrarse en la mayoría de artículos por 
Internet. Entre ellos:

* [Python-specific code smells](https://rules.sonarsource.com/python/type/Code%20Smell)*
* [CodeSmell](http://wiki.c2.com/?CodeSmell)*
* [Live Coding con Marta Gómez](https://www.youtube.com/watch?v=F_clG9ZupXo)*
* [The Python Idioms](https://delapuente.github.io/presentations/idiomatic-python/index.html#/)